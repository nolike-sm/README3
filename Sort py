============================================================
ДЕМОНСТРАЦИЯ АЛГОРИТМОВ СОРТИРОВКИ И ПОИСКА
============================================================

Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]
Цель поиска: 25
------------------------------------------------------------


ФИНАЛЬНЫЙ РЕЗУЛЬТАТ: [11, 12, 22, 25, 34, 64, 90]


Программа
# Алгоритмы сортировки и поиска

# 1. Сортировка пузырьком (Bubble Sort)
def bubble_sort(arr):
    """
    Сортировка пузырьком
    Сложность: O(n²) в худшем случае, O(n) в лучшем случае
    """
    print("Начало сортировки пузырьком")
    n = len(arr)
    print(f"Длина массива: {n}")
    
    for i in range(n-1):
        print(f"\nПроход {i+1}:")
        swapped = False
        for j in range(0, n-i-1):
            print(f"  Сравниваем элементы {arr[j]} и {arr[j+1]} на позициях {j} и {j+1}")
            if arr[j] > arr[j+1]:
                print(f"  Меняем местами {arr[j]} и {arr[j+1]}")
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
                print(f"  Текущее состояние массива: {arr}")
            else:
                print(f"  Элементы в правильном порядке, переходим к следующей паре")
        
        # Если не было обменов, массив уже отсортирован
        if not swapped:
            print("  Не было обменов - массив отсортирован!")
            break
        print(f"После прохода {i+1}: {arr}")
    
    print("Сортировка пузырьком завершена!")
    return arr

# 2. Сортировка Шелла (Shell Sort)
def shell_sort(arr):
    """
    Сортировка Шелла
    Сложность: O(n log n) в среднем случае
    """
    print("Начало сортировки Шелла")
    n = len(arr)
    gap = n // 2
    print(f"Начальный шаг (gap): {gap}")
    
    step = 1
    while gap > 0:
        print(f"\nШаг {step}, gap = {gap}:")
        for i in range(gap, n):
            temp = arr[i]
            print(f"  Обрабатываем элемент {temp} на позиции {i}")
            j = i
            while j >= gap and arr[j - gap] > temp:
                print(f"    Сдвигаем элемент {arr[j - gap]} с позиции {j-gap} на позицию {j}")
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
            print(f"    Вставляем {temp} на позицию {j}")
            print(f"    Текущее состояние: {arr}")
        gap //= 2
        step += 1
        print(f"Новый gap: {gap}")
    
    print("Сортировка Шелла завершена!")
    return arr

# 3. Быстрая сортировка (Quick Sort)
def partition(arr, low, high, depth=0):
    """
    Вспомогательная функция для быстрой сортировки
    """
    indent = "  " * depth
    print(f"{indent}Разделение массива {arr[low:high+1]} (индексы {low}-{high})")
    
    pivot = arr[high]
    print(f"{indent}Опорный элемент: {pivot} (индекс {high})")
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            if i != j:
                print(f"{indent}  Меняем {arr[i]} и {arr[j]} (индексы {i} и {j})")
                arr[i], arr[j] = arr[j], arr[i]
                print(f"{indent}  Текущее состояние: {arr}")
    
    if i + 1 != high:
        print(f"{indent}  Ставим опорный элемент на позицию {i+1}")
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        print(f"{indent}  После разделения: {arr}")
    
    return i + 1

def quick_sort(arr, low, high, depth=0):
    """
    Быстрая сортировка
    Сложность: O(n log n) в среднем случае, O(n²) в худшем случае
    """
    indent = "  " * depth
    if low < high:
        print(f"{indent}Рекурсивный вызов для {arr[low:high+1]}")
        pi = partition(arr, low, high, depth)
        
        print(f"{indent}Сортируем левую часть: {arr[low:pi]}")
        quick_sort(arr, low, pi - 1, depth + 1)
        
        print(f"{indent}Сортируем правую часть: {arr[pi+1:high+1]}")
        quick_sort(arr, pi + 1, high, depth + 1)

# 4. Линейный поиск (Linear Search)
def linear_search(arr, target):
    """
    Линейный поиск
    Сложность: O(n)
    """
    print(f"Начало линейного поиска элемента {target}")
    print(f"Массив для поиска: {arr}")
    
    for i in range(len(arr)):
        print(f"  Проверяем элемент {arr[i]} на позиции {i}")
        if arr[i] == target:
            print(f"  Элемент {target} найден на позиции {i}!")
            return i
    
    print(f"  Элемент {target} не найден в массиве")
    return -1

# 5. Поиск Фибоначчи (Fibonacci Search)
def fibonacci_search(arr, x):
    """
    Поиск Фибоначчи
    Сложность: O(log n)
    """
    print(f"Начало поиска Фибоначчи элемента {x}")
    print(f"Отсортированный массив: {arr}")
    
    n = len(arr)
    fib_m2, fib_m1, fib_m = 0, 1, 1
    
    print("Вычисляем числа Фибоначчи:")
    while fib_m < n:
        print(f"  F(m-2)={fib_m2}, F(m-1)={fib_m1}, F(m)={fib_m}")
        fib_m2, fib_m1, fib_m = fib_m1, fib_m, fib_m1 + fib_m
    
    print(f"Наибольшее число Фибоначчи <= {n}: F(m)={fib_m1}")
    
    offset = -1
    step = 1
    
    while fib_m > 1:
        print(f"\nШаг {step}:")
        i = min(offset + fib_m2, n - 1)
        print(f"  Проверяем позицию {i}: элемент {arr[i]}")
        
        if arr[i] < x:
            print(f"  {arr[i]} < {x}, ищем в правой части")
            fib_m, fib_m1, fib_m2 = fib_m1, fib_m2, fib_m1 - fib_m2
            offset = i
        elif arr[i] > x:
            print(f"  {arr[i]} > {x}, ищем в левой части")
            fib_m, fib_m1, fib_m2 = fib_m2, fib_m1 - fib_m2, fib_m2 - (fib_m1 - fib_m2)
        else:
            print(f"  Элемент {x} найден на позиции {i}!")
            return i
        step += 1
    
    if fib_m1 and offset < n - 1 and arr[offset + 1] == x:
        print(f"Элемент {x} найден на позиции {offset + 1}!")
        return offset + 1
    
    print(f"Элемент {x} не найден в массиве")
    return -1

# Демонстрация работы алгоритмов
def main():
    print("=" * 60)
    print("ДЕМОНСТРАЦИЯ АЛГОРИТМОВ СОРТИРОВКИ И ПОИСКА")
    print("=" * 60)
    
    # Тестовые данные
    original_arr = [64, 34, 25, 12, 22, 11, 90]
    sorted_arr = [11, 12, 22, 25, 34, 64, 90]
    target = 25
    
    print(f"\nИсходный массив: {original_arr}")
    print(f"Отсортированный массив: {sorted_arr}")
    print(f"Цель поиска: {target}")
    print("-" * 60)
    
    # Сортировка пузырьком
    print("\n" + "=" * 40)
    print("1. СОРТИРОВКА ПУЗЫРЬКОМ")
    print("=" * 40)
    arr1 = original_arr.copy()
    bubble_sort(arr1)
    print(f"ФИНАЛЬНЫЙ РЕЗУЛЬТАТ: {arr1}")
    
    # Сортировка Шелла
    print("\n" + "=" * 40)
    print("2. СОРТИРОВКА ШЕЛЛА")
    print("=" * 40)
    arr2 = original_arr.copy()
    shell_sort(arr2)
    print(f"ФИНАЛЬНЫЙ РЕЗУЛЬТАТ: {arr2}")
    
    # Быстрая сортировка
    print("\n" + "=" * 40)
    print("3. БЫСТРАЯ СОРТИРОВКА")
    print("=" * 40)
    arr3 = original_arr.copy()
    print(f"Начальный массив: {arr3}")
    quick_sort(arr3, 0, len(arr3) - 1)
    print(f"ФИНАЛЬНЫЙ РЕЗУЛЬТАТ: {arr3}")
    
    # Линейный поиск
    print("\n" + "=" * 40)
    print("4. ЛИНЕЙНЫЙ ПОИСК")
    print("=" * 40)
    result_linear = linear_search(sorted_arr, target)
    print(f"РЕЗУЛЬТАТ: элемент найден на позиции {result_linear}" if result_linear != -1 
          else "РЕЗУЛЬТАТ: элемент не найден")
    
    # Поиск Фибоначчи
    print("\n" + "=" * 40)
    print("5. ПОИСК ФИБОНАЧЧИ")
    print("=" * 40)
    result_fib = fibonacci_search(sorted_arr, target)
    print(f"РЕЗУЛЬТАТ: элемент найден на позиции {result_fib}" if result_fib != -1 
          else "РЕЗУЛЬТАТ: элемент не найден")
    
    print("\n" + "=" * 60)
    print("СРАВНЕНИЕ АЛГОРИТМОВ:")
    print("- Сортировка пузырьком: простая, но медленная O(n²)")
    print("- Сортировка Шелла: улучшенная версия сортировки вставками")
    print("- Быстрая сортировка: эффективная O(n log n), но сложная")
    print("- Линейный поиск: простой O(n), для любых массивов")
    print("- Поиск Фибоначчи: эффективный O(log n), только для отсортированных массивов")
    print("=" * 60)

if __name__ == "__main__":
    main()
