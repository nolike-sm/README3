
# Алгоритмы и структуры данных

## Анализ алгоритмов сортировки

### Сортировка выбором (Selection Sort)

**Определение:**
Сортировка выбором представляет собой алгоритм сортировки, который концептуально разделяет массив на две секции: отсортированную и неотсортированную. На каждой итерации алгоритм идентифицирует минимальный элемент в неотсортированном сегменте и производит его обмен с первым элементом этого сегмента.

**Детальный анализ:**
- Алгоритм последовательно находит минимальный элемент в неотсортированной части массива и осуществляет его замену с начальным элементом неотсортированного сегмента
- Внешний цикл `for` выполняется ровно `n-1` раз для массива размером `n`
- Внутренний цикл `for` в наихудшем сценарии выполняет `n-1`, затем `n-2`, и так далее операций сравнения на каждой итерации внешнего цикла
- Суммарное количество операций сравнения приблизительно равно `n*(n-1)/2`

**Временная сложность:** O(n²)

**Обоснование квадратичной сложности:** Наличие двух вложенных циклов, где каждый из них в среднем и худшем случае пропорционален `n`. Внутренний цикл может выполняться до `n` раз для каждой из `n` итераций внешнего цикла, что приводит к квадратичной зависимости времени выполнения.

---

### Сортировка обменом (пузырьком) (Bubble Sort)

**Определение:**
Сортировка обменом, также известная как пузырьковая сортировка, представляет собой простой алгоритм, который многократно проходит через массив, сравнивая смежные элементы и производя их обмен, когда они расположены в неправильном порядке.

**Детальный анализ:**
- Алгоритм последовательно проходит через массив, сравнивая соседние элементы и меняя их позиции, если левый элемент превышает правый, обеспечивая "всплытие" наибольшего элемента к концу массива
- Внешний цикл `for` выполняется `n-1` раз
- Внутренний цикл `for` в наихудшем сценарии (когда массив отсортирован в обратном порядке) выполняет `n-1`, затем `n-2`, и так далее операций
- Оптимизация с использованием флага `swapped` позволяет досрочно завершить выполнение, если массив оказывается уже отсортированным

**Временная сложность:**
- **Наихудший случай:** O(n²) — когда массив отсортирован в обратном порядке
- **Наилучший случай:** O(n) — когда массив уже отсортирован и срабатывает оптимизация
- **Средний случай:** O(n²)

**Обоснование сложности:** В наихудшем сценарии, аналогично сортировке выбором, алгоритм требует приблизительно `n*(n-1)/2` операций сравнения и потенциальных обменов.

---

### Сортировка вставками (Insertion Sort)

**Определение:**
Сортировка вставками — это алгоритм сортировки, в котором элементы входной последовательности обрабатываются последовательно, и каждый вновь поступивший элемент размещается в соответствующую позицию среди ранее упорядоченных элементов.

**Детальный анализ:**
- Алгоритм постепенно строит отсортированную часть списка, начиная с первого элемента. Каждый последующий элемент вставляется в корректную позицию внутри уже отсортированного сегмента
- Внешний цикл `for` проходит через `n-1` элементов
- Внутренний цикл `while` в наихудшем сценарии (массив отсортирован в обратном порядке) может выполнить до `i` итераций на `i`-ой итерации внешнего цикла

**Временная сложность:**
- **Наихудший случай:** O(n²) — когда массив отсортирован в обратном порядке, каждый элемент может потребовать до `i` операций сдвига
- **Наилучший случай:** O(n) — когда массив уже отсортирован, внутренний цикл `while` не активируется
- **Средний случай:** O(n²)

**Обоснование квадратичной сложности:** В наихудшем сценарии общее количество операций сдвига и сравнений составляет `1 + 2 + 3 + ... + (n-1) = n*(n-1)/2`.

---

### Сортировка слиянием (Merge Sort)

**Определение:**
Сортировка слиянием — это алгоритм сортировки, который упорядочивает списки (или другие структуры данных с последовательным доступом к элементам, такие как потоки) в определенном порядке.

**Детальный анализ:**
- Алгоритм рекурсивно разделяет массив на две равные части до достижения подмассивов размером 1
- Затем происходит слияние этих подмассивов с формированием более крупных отсортированных сегментов
- Этот процесс реализуется с помощью функции `merge`, которая объединяет два предварительно отсортированных подмассива

**Временная сложность:** O(n log n)

**Обоснование сложности n log n:**
- **Глубина рекурсии:** Массив делится пополам на каждом уровне рекурсии. Количество уровней (глубина рекурсивного дерева) составляет `log n`
- **Работа на уровне:** На каждом уровне рекурсии происходит слияние `n` элементов (всех элементов массива). Функция `merge` для всего массива на одном уровне выполняет O(n) операций
- **Общая сложность:** `log n` уровней × `n` элементов на уровне = O(n log n)

---

### Сортировка Шелла (Shell Sort)

**Определение:**
Сортировка Шелла — это алгоритм сортировки, представляющий собой усовершенствованную версию сортировки вставками. Основная идея метода Шелла заключается в сравнении элементов, расположенных не только рядом, но и на определенном расстоянии друг от друга.

**Детальный анализ:**
- Это модификация сортировки вставками, которая сначала сортирует элементы, находящиеся на определенном расстоянии (gap), затем постепенно уменьшает это расстояние и повторяет процесс
- Выбор последовательности расстояний (например, `n/2, n/4, ..., 1`) существенно влияет на производительность алгоритма

**Временная сложность:**
- Зависит от выбранной последовательности расстояний. Для стандартной последовательности (`n/2^k`) сложность составляет **O(n^(3/2))** или **O(n log² n)** в среднем случае, но может ухудшаться
- В наихудшем сценарии (для определенных последовательностей) может достигать **O(n²)**
- Для последовательности Кнута (gap = `3h + 1`) сложность составляет **O(n^(3/2))**
- В общем случае, точная сложность часто выражается как **O(n^p)**, где 1 < p ≤ 2

**Обоснование сложности:** Алгоритм использует вложенные циклы, но внутренний цикл (по `j`) не всегда проходит `n` раз, как в пузырьковой сортировке. Количество итераций зависит от расстояния. В среднем случае количество итераций внутреннего цикла возрастает медленнее, чем `n`, что приводит к сложности между O(n) и O(n²).

---

### Быстрая сортировка (Quick Sort)

**Определение:**
Быстрая сортировка — это высокоэффективный алгоритм сортировки, использующий принцип «разделяй и властвуй».

**Детальный анализ:**
- Выбирается опорный элемент (pivot). Массив перераспределяется таким образом, что элементы, меньшие или равные опорному, располагаются слева от него, а большие — справа
- Затем рекурсивно сортируются левая и правая части
- Выбор опорного элемента является критически важным для производительности алгоритма

**Временная сложность:**
- **Средний случай:** O(n log n) — когда опорный элемент делит массив приблизительно пополам на каждом шаге
- **Наихудший случай:** O(n²) — когда опорный элемент всегда является минимальным или максимальным (например, массив уже отсортирован, и опорный всегда последний). В этом случае глубина рекурсивного дерева составляет `n`, а на каждом уровне выполняется `n` операций сравнения
- **Наилучший случай:** O(n log n) — когда опорный элемент всегда делит массив точно пополам

**Обоснование сложности:**
- **Средний/Наилучший случай:** Глубина рекурсии `log n`, на каждом уровне `n` сравнений (в функции `partition`). Итого: `n × log n`
- **Наихудший случай:** Глубина рекурсии `n`, на каждом уровне до `n`, `n-1`, `n-2`, ... сравнений. Итого: `n + (n-1) + ... + 1 = n(n+1)/2 ≈ O(n²)`

---

### Пирамидальная сортировка (Heap Sort)

**Определение:**
Пирамидальная сортировка — это алгоритм сортировки сравнением, использующий структуру данных "двоичная куча".

**Детальный анализ:**
- Сначала строится max-heap (бинарное дерево, где родительский элемент всегда больше или равен дочерним)
- Затем максимальный элемент (корень) извлекается и помещается в конец массива. Размер кучи уменьшается, и свойство heap восстанавливается для оставшейся части

**Временная сложность:** O(n log n)

**Обоснование сложности n log n:**
- **Построение кучи:** Функция `build_max_heap` выполняет операцию `heapify` для `n/2` узлов. Каждый вызов `heapify` может иметь глубину `log n`. Суммарно это O(n) (математически доказывается, поскольку большинство узлов расположены ближе к листьям)
- **Сортировка:** Цикл `for` выполняется `n-1` раз. Внутри него вызывается `heapify`, который работает за O(log n) (глубина дерева). Итого: `n × O(log n) = O(n log n)`
- **Общая сложность:** O(n) (построение) + O(n log n) (сортировка) = O(n log n)

---

## Анализ алгоритмов поиска

### Последовательный (линейный) поиск (Linear Search)

**Определение:**
Последовательный (линейный) поиск — это простейший алгоритм, который последовательно проверяет каждый элемент в наборе данных до тех пор, пока не будет обнаружен искомый элемент или не будет полностью пройден весь список.

**Детальный анализ:**
- Алгоритм последовательно просматривает элементы массива, сравнивая их с целевым значением

**Временная сложность:**
- **Наихудший случай:** O(n) — когда элемент расположен в конце массива или отсутствует
- **Наилучший случай:** O(1) — когда элемент находится в начале массива
- **Средний случай:** O(n/2) ≈ O(n)

**Обоснование линейной сложности:** В наихудшем сценарии необходимо проверить все `n` элементов массива.

---

### Бинарный поиск (Binary Search)

**Определение:**
Бинарный поиск — это алгоритм для нахождения элемента в предварительно отсортированном массиве.

**Детальный анализ:**
- Алгоритм работает исключительно с отсортированными массивами
- На каждом шаге область поиска сокращается вдвое посредством сравнения с элементом, расположенным в середине текущего сегмента

**Временная сложность:** O(log n)

**Обоснование логарифмической сложности:** На каждом шаге размер области поиска уменьшается приблизительно вдвое. Количество шагов, необходимых для сокращения `n` до 1, равно `log₂ n`.

---

### Интерполирующий поиск (Interpolation Search)

**Определение:**
Интерполирующий поиск (интерполяционный поиск) — это алгоритм поиска значения в упорядоченном массиве чисел, который демонстрирует более высокую производительность по сравнению с бинарным поиском при равномерном распределении данных.

**Детальный анализ:**
- Похож на бинарный поиск, но вместо простого деления пополам, предполагает позицию элемента на основе его значения и значений на границах текущего сегмента, исходя из предположения о равномерном распределении данных

**Временная сложность:**
- **Средний случай (равномерное распределение):** O(log log n)
- **Наихудший случай (неравномерное распределение):** O(n)

**Обоснование сложности:**
- **Средний случай:** При равномерном распределении данных, на каждом шаге размер области поиска уменьшается значительно быстрее, чем в бинарном поиске. Количество шагов приблизительно равно `log log n`
- **Наихудший случай:** Если данные распределены неравномерно (например, большинство элементов сосредоточено в начале массива), вычисляемая позиция `pos` может оказываться близко к `lo`, и алгоритм может деградировать до линейного сканирования, проверяя каждый элемент по отдельности

---

### Поиск по Фибоначчи (Fibonacci Search)

**Определение:**
Поиск методом Фибоначчи — это итеративный алгоритм для поиска экстремума (минимума или максимума) унимодальной функции на заданном интервале, а также метод поиска нужного значения в отсортированном массиве.

**Детальный анализ:**
- Использует числа Фибоначчи для определения точек разбиения массива, аналогично бинарному поиску (деление на части), но с различными пропорциями

**Временная сложность:** O(log n)

**Обоснование логарифмической сложности:** Количество чисел Фибоначчи до `n` приблизительно равно `log n`. Каждая итерация цикла `while` уменьшает размер области поиска, используя меньшие числа Фибоначчи, что приводит к O(log n) итерациям.
```
